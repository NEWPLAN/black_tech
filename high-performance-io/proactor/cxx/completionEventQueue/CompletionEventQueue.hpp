/**
 * \file CompletionEventQueue.hpp
 * \author Ronald T. Fernandez
 * \version 1.0
 * \brief Defines the hook method for processing the completion event (asynchronous operation)
 * generated by asynchronous operation.
 */

#ifndef COMPLETIONEVENTQUEUE_COMPLETIONEVENTQUEUE_HPP_
#define COMPLETIONEVENTQUEUE_COMPLETIONEVENTQUEUE_HPP_

#include <deque>
#include <memory>
#include <mutex>
#include <utility>

#include "../asyncOperation/AsynchronousOperation.hpp"

namespace proactor {
namespace completionEventQueue {

/**
 * This class defines the queue of completed events.
 */
template <typename T>
class CompletionEventQueue : private  std::deque<asyncOperation::AsynchronousOperation<T>*> {
private:
	/**
	 * Lock to push and pop events in the queue
	 */
	std::mutex mutex;
	/**
	 * Operations which are being processed and which are not terminated. This counter is
	 * useful because, in case the system needs to be shut down, all the pending operations
	 * are correctly calculated and finished before the full system terminates
	 */
	unsigned int pendingOperations;
public:
	/**
	 * Class constructor
	 */
	CompletionEventQueue() : std::deque<asyncOperation::AsynchronousOperation<T>*>(), pendingOperations(0) {
	};

	/**
	 * Class destructor
	 */
	virtual ~CompletionEventQueue() {
		this->clear();
	};

	/**
	 * Pop an operation from the completion queue and remove it from the list
	 * @return An operation from the completion list
	 */
	asyncOperation::AsynchronousOperation<T>* pop() {
		// Lock the queue
		std::lock_guard<std::mutex> locker(mutex);

		// Get the first element
		asyncOperation::AsynchronousOperation<T>* p = this->front();

		// Remove the first element from the queue
		this->pop_front();

		// Return the retrieved first element
		return p;
	}

	/**
	 * Add an operation to the completion queue
	 */
	void push(asyncOperation::AsynchronousOperation<T> *operation) {
		// Lock the queue
		std::lock_guard<std::mutex> locker(mutex);
		// Insert the element into the queue
		this->push_back(operation);

		// Update the counter of pending operations
		if (pendingOperations == 0)
			throw std::exception();
		--pendingOperations;

	};

	/**
	 * Get the size of the completion queue
	 * @return	Size of the queue
	 */
	const size_t size() {
		// Lock the queue
		std::lock_guard<std::mutex> locker(mutex);
		// Return the size of the queue
		return std::deque<asyncOperation::AsynchronousOperation<T>*>::size();
	}

	/**
	 * Increment the number of operations which are being processed but
	 * not terminated
	 */
	void incrementPendingOperations() {
		std::lock_guard<std::mutex> locker(mutex);
		++pendingOperations;
	}

	/**
	 * Verify whether ther are operations which are waiting to be completed
	 */
	bool arePendingOperations() {
		// We use the lock here to ensure that the counter is not modified
		std::lock_guard<std::mutex> locker(mutex);
		return (pendingOperations == 0);
	}
};

}
}

#endif /* COMPLETIONEVENTQUEUE_COMPLETIONEVENTQUEUE_HPP_ */
